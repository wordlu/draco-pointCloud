// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_POINTCLOUD_LD_DATA_H_
#define FLATBUFFERS_GENERATED_POINTCLOUD_LD_DATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "header_generated.h"

namespace ld_data {

struct Field;
struct FieldBuilder;

struct PointCloud;
struct PointCloudBuilder;

enum DataType : uint8_t {
  DataType_INT8 = 1,
  DataType_UINT8 = 2,
  DataType_INT16 = 3,
  DataType_UINT16 = 4,
  DataType_INT32 = 5,
  DataType_UINT32 = 6,
  DataType_FLOAT32 = 7,
  DataType_FLOAT64 = 8,
  DataType_INT64 = 9,
  DataType_UINT64 = 10,
  DataType_MIN = DataType_INT8,
  DataType_MAX = DataType_UINT64
};

inline const DataType (&EnumValuesDataType())[10] {
  static const DataType values[] = {
    DataType_INT8,
    DataType_UINT8,
    DataType_INT16,
    DataType_UINT16,
    DataType_INT32,
    DataType_UINT32,
    DataType_FLOAT32,
    DataType_FLOAT64,
    DataType_INT64,
    DataType_UINT64
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[11] = {
    "INT8",
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "FLOAT32",
    "FLOAT64",
    "INT64",
    "UINT64",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType_INT8, DataType_UINT64)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(DataType_INT8);
  return EnumNamesDataType()[index];
}

struct Field FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_DATA_TYPE = 8,
    VT_COUNT = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  ld_data::DataType data_type() const {
    return static_cast<ld_data::DataType>(GetField<uint8_t>(VT_DATA_TYPE, 1));
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct FieldBuilder {
  typedef Field Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Field::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Field::VT_OFFSET, offset, 0);
  }
  void add_data_type(ld_data::DataType data_type) {
    fbb_.AddElement<uint8_t>(Field::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 1);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(Field::VT_COUNT, count, 0);
  }
  explicit FieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Field>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Field> CreateField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    ld_data::DataType data_type = ld_data::DataType_INT8,
    uint32_t count = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Field> CreateFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    ld_data::DataType data_type = ld_data::DataType_INT8,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ld_data::CreateField(
      _fbb,
      name__,
      offset,
      data_type,
      count);
}

struct PointCloud FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointCloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_FIELDS = 6,
    VT_SHAPE = 8,
    VT_IS_BIGENDIAN = 10,
    VT_COMPRESSION_INFO = 12,
    VT_DATA = 14
  };
  const ld_data::Header *header() const {
    return GetPointer<const ld_data::Header *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ld_data::Field>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ld_data::Field>> *>(VT_FIELDS);
  }
  const ::flatbuffers::String *shape() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHAPE);
  }
  int8_t is_bigendian() const {
    return GetField<int8_t>(VT_IS_BIGENDIAN, 0);
  }
  const ::flatbuffers::String *compression_info() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPRESSION_INFO);
  }
  const ::flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyString(shape()) &&
           VerifyField<int8_t>(verifier, VT_IS_BIGENDIAN, 1) &&
           VerifyOffset(verifier, VT_COMPRESSION_INFO) &&
           verifier.VerifyString(compression_info()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct PointCloudBuilder {
  typedef PointCloud Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<ld_data::Header> header) {
    fbb_.AddOffset(PointCloud::VT_HEADER, header);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ld_data::Field>>> fields) {
    fbb_.AddOffset(PointCloud::VT_FIELDS, fields);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::String> shape) {
    fbb_.AddOffset(PointCloud::VT_SHAPE, shape);
  }
  void add_is_bigendian(int8_t is_bigendian) {
    fbb_.AddElement<int8_t>(PointCloud::VT_IS_BIGENDIAN, is_bigendian, 0);
  }
  void add_compression_info(::flatbuffers::Offset<::flatbuffers::String> compression_info) {
    fbb_.AddOffset(PointCloud::VT_COMPRESSION_INFO, compression_info);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(PointCloud::VT_DATA, data);
  }
  explicit PointCloudBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointCloud>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointCloud> CreatePointCloud(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ld_data::Header> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ld_data::Field>>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shape = 0,
    int8_t is_bigendian = 0,
    ::flatbuffers::Offset<::flatbuffers::String> compression_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> data = 0) {
  PointCloudBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_compression_info(compression_info);
  builder_.add_shape(shape);
  builder_.add_fields(fields);
  builder_.add_header(header);
  builder_.add_is_bigendian(is_bigendian);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointCloud> CreatePointCloudDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ld_data::Header> header = 0,
    const std::vector<::flatbuffers::Offset<ld_data::Field>> *fields = nullptr,
    const char *shape = nullptr,
    int8_t is_bigendian = 0,
    const char *compression_info = nullptr,
    const std::vector<int8_t> *data = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<ld_data::Field>>(*fields) : 0;
  auto shape__ = shape ? _fbb.CreateString(shape) : 0;
  auto compression_info__ = compression_info ? _fbb.CreateString(compression_info) : 0;
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return ld_data::CreatePointCloud(
      _fbb,
      header,
      fields__,
      shape__,
      is_bigendian,
      compression_info__,
      data__);
}

inline const ld_data::PointCloud *GetPointCloud(const void *buf) {
  return ::flatbuffers::GetRoot<ld_data::PointCloud>(buf);
}

inline const ld_data::PointCloud *GetSizePrefixedPointCloud(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ld_data::PointCloud>(buf);
}

inline bool VerifyPointCloudBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ld_data::PointCloud>(nullptr);
}

inline bool VerifySizePrefixedPointCloudBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ld_data::PointCloud>(nullptr);
}

inline void FinishPointCloudBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ld_data::PointCloud> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPointCloudBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ld_data::PointCloud> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ld_data

#endif  // FLATBUFFERS_GENERATED_POINTCLOUD_LD_DATA_H_
